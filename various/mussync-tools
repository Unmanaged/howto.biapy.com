#!/bin/bash
#
# Music library convert and sync.
#
# For suggestion and bug reports, please contact
# Pierre-Yves Landuré <pierre-yves dot landure at biapy dot fr>
#
# Thanks to m31z0nyx on irc.freenode.net #debian-facile for his help i
# finding a script name.
#
VERSION="1.1.1"

SCRIPT_NAME="$(command basename "${0}")"

# Print this script help.
function usage {
  command echo "Music library convert and sync v${VERSION}
This tool convert a input (Flac) music library to an output (MP3) music folder
and keep the folder structure.

Usage :

  ${SCRIPT_NAME} [ --help ] [ --quiet ] [ --verbose ]
      [ --input-path='/path/to/flac/library' ]
      [ --output-path='/path/to/mp3/library' ]
      [ --input-format='flac' ] [ --output-format='mp3' ]
      [ --bitrate='320k' ] [ --sync-delete ]
      [ --avconv-options='--more --avconv --options' ]

  Available options are :
    * --help | -h                   : Display this message.
    * --input-path  | --in  | -i    : Set the path to the source library
                                      (default to current)
    * --output-path | --out | -o    : Set the path to the target library
                                      (default to current)
    * --input-format  | --if | -s   : Set the input format. Default to Flac.
    * --output-format | --of | -e   : Set the output format. Default to MP3.
    * --bitrate | -b                : Set the bitrate. Default to 320k.
    * --sync-delete | --delete | -d : Propagate file deletion from input
                                      library to output library.
                                      Any output file without equivalence in
                                      input library is deleted.
    * --avconv-options | -a         : Additionnal options for avconv.
                                      See avconv man page.
    * --threads | -t                : Threads number.
                                      Default to 1 thread by CPU.
    * --quiet | -q                  : Disable almost all outputs.
    * --verbose | -v                : Enable debug outputs.
"

  test -n "${1}" && exit ${1}
} # usage



# Get the absolute path for a file or directory.
#
# @param string $path A relative path.
#
# @return ${REALPATH} A absolute path.
function realpath {
  declare -g REALPATH=''

  command test ${#} -ne 1 && exit 1
  REALPATH="$(command readlink -f "${1}")"
} # realpath



# Get the absolute path for a file or directory and check the file existance.
# If the file does not exists, display an error message and exit the script.
#
# @param string $path A relative path.
#
# @return ${REALPATH} A absolute path or an empty string if file don't exists.
function realpath_check {
  declare -g REALPATH=''

  command test ${#} -ne 1 && exit 1

  realpath "${1}"

  if [ -n "${REALPATH}" -a ! -e "${REALPATH}" ]; then
    REALPATH=""
  fi

  if [ -z "${REALPATH}" ]; then
    echo "Error : File '${1}' does not exists." >&2
    exit 1
  fi
} # realpath_check



# Check if a binary is present
#
# @param string $binary The binary to check.
# @param string $package The package the binary come from.
#
# @return Exit with error if the binary is missing.
function check_binary {
  command test ${#} -ne 2 && exit 1

  # Test the binary presence.
  if [ -z "$(command which "${1}")" ]; then
    echo "Error : '${1}' is missing. Please install package '${2}'." >&2
    exit 1
  fi
} # check_binary



# Transfert cover art from input file to output file.
# Reset all cover art in output file.
#
# @param string $input_file The audio input file.
# @param string $output_file The audio output file.
#
# @return Exit with error if conversion failed.
function mussync-tools-transfert_images {
  command test ${#} -ne 2 && exit 1

  local INPUT_FILE="${1}"
  local OUTPUT_FILE="${2}"

  # Detect if input file has cover art.
  local INPUT_FILE_HAS_COVER="$(command mediainfo --Inform="General;%Cover%" "${INPUT_FILE}")"
  local METADATA_BLOCK_PICTURE='False'

  if [ "${INPUT_FILE_HAS_COVER}" != 'Yes' \
      -a -n "$(command mediainfo "${INPUT_FILE}" | command grep '^metadata_block_picture')" ]; then
    INPUT_FILE_HAS_COVER='Yes'
    METADATA_BLOCK_PICTURE='True'
  fi

  if [ "${INPUT_FILE_HAS_COVER}" = 'Yes' ]; then
    test "${QUIET}" != 'True' && echo -n "Transfering cover art to $(command basename "${OUTPUT_FILE}")... "

    # Detect Cover MIME type.
    local IMAGE_MIME_TYPE="$(command mediainfo --Inform="General;%Cover_Mime%" "${INPUT_FILE}")"
    local IMAGE_EXTENSION="$(echo "${IMAGE_MIME_TYPE}" | command cut --delimiter='/' --fields=2)"

    if [ -z "${IMAGE_EXTENSION}" ]; then
      if [ "${METADATA_BLOCK_PICTURE}" != 'True' ]; then
        # Unable to determine cover mime type.
        test "${QUIET}" != 'True' && echo "Failed (MIME type unsupported (${IMAGE_MIME_TYPE}))."
        return 1
      fi
    else
      # Create image folder.
      local IMAGE_PATH="$(command mktemp -t "tmp.XXXXXXXXXX.${IMAGE_EXTENSION}")"
    fi

    # Detect input file format and audio format.
    local INPUT_FILE_FORMAT="$(command mediainfo --Inform="General;%Format%" "${INPUT_FILE}")"
    local INPUT_FILE_AUDIO_FORMAT="$(command mediainfo --Inform="Audio;%Format%" "${INPUT_FILE}")"

    test "${QUIET}" != 'True' && echo -n "Extracting... "

    case "${INPUT_FILE_FORMAT}" in
      'FLAC' )
        # File is Flac

        # List IMAGE metadata blocs.
        # Assume first bloc is cover art.
        local BLOCK_NUMBER="$(command metaflac --list --block-type='PICTURE' "${INPUT_FILE}" \
            | command grep --max-count=1 '^METADATA block' \
            | command sed -e 's/^.*#//')"

        # Determine cover image MIME type.
        IMAGE_MIME_TYPE="$(command metaflac --block-number="${BLOCK_NUMBER}" --list "${INPUT_FILE}" \
            | command grep "MIME type:" \
            | command sed -e 's/.*MIME type: //g')"

        # Extract cover image from file.
        command metaflac --block-number="${BLOCK_NUMBER}" \
            --export-picture-to="${IMAGE_PATH}" "${INPUT_FILE}"
        ;;

      'MPEG Audio' )
        # File is MP3
        local MP3_IMAGE_PATH="$(command mktemp -d -t "tmp.XXXXXXXXXX")"

        if [ "${VERBOSE}" = 'True' ]; then
          command eyeD3 --write-images="${MP3_IMAGE_PATH}" "${INPUT_FILE}"
        else
          command eyeD3 --write-images="${MP3_IMAGE_PATH}" "${INPUT_FILE}" > '/dev/null' 2>&1
        fi

        if [ -e "${MP3_IMAGE_PATH}/FRONT_COVER.${IMAGE_EXTENSION}" ]; then
          command mv "${MP3_IMAGE_PATH}/FRONT_COVER.${IMAGE_EXTENSION}" "${IMAGE_PATH}"
        fi

        command rm -r "${MP3_IMAGE_PATH}"
        ;;

      'OGG' )
        # File is an OGG container.
        case "${INPUT_FILE_AUDIO_FORMAT}" in

          'Vorbis' )
            # File is OGG Vorbis.

            local IMAGE_WITH_HEADERS_PATH="$(command mktemp -t "tmp.XXXXXXXXXX")"

            command vorbiscomment --list --raw "${INPUT_FILE}" \
                | command grep --max-count=1 '^metadata_block_picture=' \
                | command sed -e 's/^metadata_block_picture=//' \
                | command base64 --decode --wrap=0 \
              > "${IMAGE_WITH_HEADERS_PATH}"

            # Fetch data lengths.
            local MIME_LENGTH="$(command dd skip=4 count=4 bs=1 \
                if="${IMAGE_WITH_HEADERS_PATH}" 2>'/dev/null' \
                | command xxd -p -g0 \
                | command xargs -iHEX printf "%d" '0xHEX')"

            IMAGE_MIME_TYPE="$(command dd skip=8 count="${MIME_LENGTH}" bs=1 \
                if="${IMAGE_WITH_HEADERS_PATH}" 2>'/dev/null')"

            # Now we try to detect extension and create the temporary image file.
            IMAGE_EXTENSION="$(echo "${IMAGE_MIME_TYPE}" | command cut --delimiter='/' --fields=2)"
            if [ -z "${IMAGE_EXTENSION}" ]; then
              # Unable to determine cover mime type.
              test -e "${IMAGE_WITH_HEADERS_PATH}" && command rm "${IMAGE_WITH_HEADERS_PATH}"

              test "${QUIET}" != 'True' && echo "Failed (MIME type unsupported (${IMAGE_MIME_TYPE}))."
              return 1
            fi

            IMAGE_PATH="$(command mktemp -t "tmp.XXXXXXXXXX.${IMAGE_EXTENSION}")"

            local DESCRIPTION_SKIP="$((8 + ${MIME_LENGTH}))"
            local DESCRIPTION_LENGTH="$(command dd skip=${DESCRIPTION_SKIP} count=4 bs=1 \
                if="${IMAGE_WITH_HEADERS_PATH}" 2>'/dev/null' \
                | command xxd -p -g0 \
                | command xargs -iHEX printf "%d" '0xHEX')"
            local IMAGE_LENGTH_SKIP="$((${DESCRIPTION_SKIP} + ${DESCRIPTION_LENGTH} + 20))"
            local IMAGE_LENGTH="$(command dd skip=${IMAGE_LENGTH_SKIP} count=4 bs=1 \
                if="${IMAGE_WITH_HEADERS_PATH}" 2>'/dev/null' \
                | command xxd -p -g0 \
                | command xargs -iHEX printf "%d" '0xHEX')"

            local IMAGE_SKIP="$((${IMAGE_LENGTH_SKIP} + 4))"
            # Extract image.

            if [ "${VERBOSE}" = 'True' ]; then
              command dd skip=${IMAGE_SKIP} count=${IMAGE_LENGTH} bs=1 \
                  if="${IMAGE_WITH_HEADERS_PATH}" of="${IMAGE_PATH}"
            else
              command dd skip=${IMAGE_SKIP} count=${IMAGE_LENGTH} bs=1 \
                  if="${IMAGE_WITH_HEADERS_PATH}" of="${IMAGE_PATH}" 2>'/dev/null'
             fi

            # Delete vorbiscomment raw file.
            test -e "${IMAGE_WITH_HEADERS_PATH}" && command rm "${IMAGE_WITH_HEADERS_PATH}"
            ;;

          * )
            test -e "${IMAGE_PATH}" && command rm "${IMAGE_PATH}"
            test "${QUIET}" != 'True' && echo "Failed (Ogg audio encoding unsupported (${INPUT_FILE_AUDIO_FORMAT}))."
            return 1
            ;;

        esac

        ;;

      * )
        test -e "${IMAGE_PATH}" && command rm "${IMAGE_PATH}"

        test "${QUIET}" != 'True' && echo "Failed (Input file format unsupported (${INPUT_FILE_FORMAT}))."
        return 1
        ;;

    esac

    # Test if an image has been extracted from INPUT_FILE and if we have an OUTPUT_FILE.
    if [ -s "${IMAGE_PATH}" -a -e "${OUTPUT_FILE}" ]; then
      test "${QUIET}" != 'True' && echo -n "Importing... "

      # Detect output file format and audio format.
      local OUTPUT_FILE_FORMAT="$(command mediainfo --Inform="General;%Format%" "${OUTPUT_FILE}")"
      local OUTPUT_FILE_AUDIO_FORMAT="$(command mediainfo --Inform="Audio;%Format%" "${OUTPUT_FILE}")"

      case "${OUTPUT_FILE_FORMAT}" in
        'FLAC' )
          # File is Flac
          # Remove existing images.
          command metaflac --block-type='PICTURE' --dont-use-padding --remove "${OUTPUT_FILE}"
          # Insert cover image from file.
          command metaflac --import-picture-from="${IMAGE_PATH}" "${OUTPUT_FILE}"
          ;;

        'MPEG Audio' )
          # File is MP3
          if [ "${VERBOSE}" = 'True' ]; then
            # Remove existing images.
            command eyeD3 --remove-images "${OUTPUT_FILE}"
            # Insert cover image from file
            command eyeD3 --add-image="${IMAGE_PATH}:FRONT_COVER" "${OUTPUT_FILE}"
          else
            # Remove existing images.
            command eyeD3 --remove-images "${OUTPUT_FILE}" > '/dev/null' 2>&1
            # Insert cover image from file
            command eyeD3 --add-image="${IMAGE_PATH}:FRONT_COVER" "${OUTPUT_FILE}" > '/dev/null' 2>&1
          fi
          ;;

        'OGG' )
          # File is an OGG container.
          case "${OUTPUT_FILE_AUDIO_FORMAT}" in

            'Vorbis' )
              # File is OGG Vorbis.

              # Export existing comments to file.
              local COMMENTS_PATH="$(command mktemp -t "tmp.XXXXXXXXXX")"
              command vorbiscomment --list --raw "${OUTPUT_FILE}" > "${COMMENTS_PATH}"

              # Remove existing images.
              command sed -i -e '/^metadata_block_picture/d' "${COMMENTS_PATH}"

              # Insert cover image from file.

              # metadata_block_picture format.
              # See: https://xiph.org/flac/format.html#metadata_block_picture

              local IMAGE_WITH_HEADER="$(command mktemp -t "tmp.XXXXXXXXXX")"
              local DESCRIPTION=""

              # Reset cache file.
              echo -n "" > "${IMAGE_WITH_HEADER}"

              # Picture type <32>.
              command printf "0: %.8x" 3 | command xxd -r -g0 \
                      >> "${IMAGE_WITH_HEADER}"
              # Mime type length <32>.
              command printf "0: %.8x" $(echo -n "${IMAGE_MIME_TYPE}" | command wc -c) \
                        | command xxd -r -g0 \
                      >> "${IMAGE_WITH_HEADER}"
              # Mime type (n * 8)
              echo -n "${IMAGE_MIME_TYPE}" >> "${IMAGE_WITH_HEADER}"
              # Description length <32>.
              command printf "0: %.8x" $(echo -n "${DESCRIPTION}" | command wc -c) \
                        | command xxd -r -g0 \
                      >> "${IMAGE_WITH_HEADER}"
              # Description (n * 8)
              echo -n "${DESCRIPTION}" >> "${IMAGE_WITH_HEADER}"
              # Picture with <32>.
              command printf "0: %.8x" 0 | command xxd -r -g0 \
                      >> "${IMAGE_WITH_HEADER}"
              # Picture height <32>.
              command printf "0: %.8x" 0 | command xxd -r -g0 \
                      >> "${IMAGE_WITH_HEADER}"
              # Picture color depth <32>.
              command printf "0: %.8x" 0 | command xxd -r -g0 \
                      >> "${IMAGE_WITH_HEADER}"
              # Picture color count <32>.
              command printf "0: %.8x" 0 | command xxd -r -g0 \
                      >> "${IMAGE_WITH_HEADER}"
              # Image file size <32>.
              command printf "0: %.8x" $(command wc -c "${IMAGE_PATH}" \
                        | command cut --delimiter=' ' --fields=1) \
                        | command xxd -r -g0 \
                      >> "${IMAGE_WITH_HEADER}"
              # Image file.
              command cat "${IMAGE_PATH}" >> "${IMAGE_WITH_HEADER}"

              echo "metadata_block_picture=$(command base64 --wrap=0 < "${IMAGE_WITH_HEADER}")" >> "${COMMENTS_PATH}"

              # Update vorbis file comments.
              command vorbiscomment --write --raw --commentfile "${COMMENTS_PATH}" "${OUTPUT_FILE}"

              # Delete cache file.
              test -e "${IMAGE_WITH_HEADER}" && command rm "${IMAGE_WITH_HEADER}"
              # Delete comments file.
              test -e "${COMMENTS_PATH}" && command rm "${COMMENTS_PATH}"
              ;;

            * )
              test -e "${IMAGE_PATH}" && command rm "${IMAGE_PATH}"
              test "${QUIET}" != 'True' && echo "Failed (Ogg audio encoding unsupported (${OUTPUT_FILE_AUDIO_FORMAT}))."
              return 1
              ;;

          esac

          ;;

        * )
          test -e "${IMAGE_PATH}" && command rm "${IMAGE_PATH}"

          test "${QUIET}" != 'True' && echo "Failed (Output file format unsupported (${OUTPUT_FILE_FORMAT}))."
          return 1
          ;;

      esac
 
    fi

    test -e "${IMAGE_PATH}" && command rm "${IMAGE_PATH}"


    test "${QUIET}" != 'True' && echo "Done."
  fi

  return 0
} # mussync-tools-transfert_images()

export -f 'mussync-tools-transfert_images'


# Convert an audio file from source library to target library.
#
# @param string $input_file The audio input file.
#
# @return Exit with error if conversion failed.
function mussync-tools-convert_file {
  command test ${#} -ne 1 && exit 1

  local INPUT_FILE="${1}"

  ## Build output file path based on input file path.
  local INPUT_FILE_PATH="$(command dirname "${INPUT_FILE}")"
  local OUTPUT_FILE_PATH="$(command echo "${INPUT_FILE_PATH}" | sed -e "s|^${INPUT_PATH}|${OUTPUT_PATH}|")"
  local SHORT_PATH="$(command echo "${INPUT_FILE_PATH}" | sed -e "s|^${INPUT_PATH}||")"

  local INPUT_FILENAME="$(command basename "${INPUT_FILE}")"
  local OUTPUT_FILENAME="${INPUT_FILENAME//\.${INPUT_EXTENSION}/.${OUTPUT_EXTENSION}}"

  local OUTPUT_FILE="${OUTPUT_FILE_PATH}/${OUTPUT_FILENAME}"

  local SHORT_INPUT_FILE="${SHORT_PATH}/${INPUT_FILENAME}"
  local SHORT_OUTPUT_FILE="${OUTPUT_FILENAME}"

  local CONVERSION_NEEDED='False'
  # Check if output file already exists.
  if [ ! -e "${OUTPUT_FILE}" ]; then
    CONVERSION_NEEDED='True'
  else
    test "${QUIET}" != 'True' && echo -n "'${SHORT_OUTPUT_FILE}' exists... "

    # Check if output file is older than input file.
    if [ "${INPUT_FILE}" -nt "${OUTPUT_FILE}" ]; then
      test "${QUIET}" != 'True' && echo "Updating."
      CONVERSION_NEEDED='True'
    else
      test "${QUIET}" != 'True' && echo "Skipping."
    fi
  fi

  if [ "${CONVERSION_NEEDED}" = 'True' ]; then
    if [ -e "${INPUT_FILE}" ]; then
      command mkdir -p "${OUTPUT_FILE_PATH}"

      if [ -d "${OUTPUT_FILE_PATH}" ]; then
        # Remove output file if it already exists.
        if [ -e "${OUTPUT_FILE}" ]; then
          command rm "${OUTPUT_FILE}"
        fi

        if [ "${INPUT_FORMAT}" = "${OUTPUT_FORMAT}" ]; then
          # Copy input to output (format is the same).
          test "${QUIET}" != 'True' && echo -n "Copying '${SHORT_INPUT_FILE}' to '${SHORT_OUTPUT_FILE}'... "
          command cp "${INPUT_FILE}" "${OUTPUT_FILE}"
        else
          # Convert input to output
          test "${QUIET}" != 'True' && echo -n "Converting '${SHORT_INPUT_FILE}' to '${SHORT_OUTPUT_FILE}'... "

          local LOG_LEVEL='quiet'
          if [ "${VERBOSE}" = 'True' ]; then
            LOG_LEVEL='info'
          fi

          if ! command avconv -i "${INPUT_FILE}" \
                  -ab "${BITRATE}" -vn -sn \
                  -map_metadata 0 \
                  -loglevel "${LOG_LEVEL}" \
                  ${AVCONV_OPTIONS} \
                  "${OUTPUT_FILE}"; then
            test "${QUIET}" != 'True' && echo "Failed."
            test -e "${OUTPUT_FILE}" && command rm "${OUTPUT_FILE}"

            return 1
          else
            test "${QUIET}" != 'True' && echo "Done."

            mussync-tools-transfert_images "${INPUT_FILE}" "${OUTPUT_FILE}"
          fi
        fi
      else
        echo "Error: unable to create folder '${OUTPUT_FILE_PATH}'." >&2

        return 1
      fi
    else
      test "${QUIET}" != 'True' && echo "'${INPUT_FILE}' not found... Skipping."
    fi
  fi

  return 0
} # mussync-tools-convert_file

# Export mussync-tools-convert_file for usage with Parallel / Sem.
export -f 'mussync-tools-convert_file'


#######################################################################################
#######################################################################################
#######################################################################################
# Include from http://wiki.grzegorz.wierzowiecki.pl/code:mutex-in-bash
#######################################################################################
#######################################################################################
#######################################################################################
# lock dirs/files
LOCK_DIR=".${SCRIPT_NAME}.lock"
PID_FILE="${SCRIPT_NAME}.pid"

# exit codes and text for them - additional features nobody needs :-)
ENO_SUCCESS=0; ETXT[0]="ENO_SUCCESS"
ENO_GENERAL=1; ETXT[1]="ENO_GENERAL"
ENO_LOCKFAIL=2; ETXT[2]="ENO_LOCKFAIL"
ENO_RECVSIG=3; ETXT[3]="ENO_RECVSIG"

BASE_LOCK_PATH="/var/lock"
LOCK_PATH="${BASE_LOCK_PATH}/${LOCK_DIR}"

# Lock the system.
#
# @param string $base_lock_path Optionnal custom path to lock file.
#                               Default to /var/lock.
# 
# @return unlock (rm) error code.
function lock {
    if [ -n "${1}" ]; then
      realpath_check "${1}"
      BASE_LOCK_PATH="${REALPATH}"
    fi

    LOCK_PATH="${BASE_LOCK_PATH}/${LOCK_DIR}"
    local PID_PATH="${LOCK_PATH}/${PID_FILE}"

    if mkdir "${LOCK_PATH}" &>'/dev/null'; then
        # lock succeeded, install signal handlers before storing the PID just in case
        # storing the PID fails
        trap 'ECODE=$?;
            echo "[${SCRIPT_NAME}] Removing lock. Exit: ${ETXT[ECODE]}($ECODE)" >&2
            test -d "${LOCK_PATH}" && rm -rf "${LOCK_PATH}"' 0

        # lock succeeded, store the PID
        echo "$$" >"${PID_PATH}"

        # the following handler will exit the script on receiving these signals
        # the trap on "0" (EXIT) from above will be triggered by this trap's
        # "exit" command!
        trap 'echo "[${SCRIPT_NAME}] Killed by a signal." >&2
              exit ${ENO_RECVSIG}' 1 2 3 15

        return ${ENO_SUCCESS}
    else
        # lock failed, now check if the other PID is alive
        OTHER_PID="$(command cat "${PID_PATH}" 2>'/dev/null')"

        # if cat wasn't able to read the file anymore, another instance probably is
        # about to remove the lock -- exit, we're *still* locked
        # Thanks to Grzegorz Wierzowiecki for pointing this race condition out on
        # http://wiki.grzegorz.wierzowiecki.pl/code:mutex-in-bash
        if [ ${?} != 0 ]; then
            # Pid file does not exists - probably directory is beeing deleted
            exit ${ENO_LOCKFAIL}
        fi

        if ! kill -0 ${OTHER_PID} &>'/dev/null'; then
            # lock is stale, remove it and restart
            unlock
            lock "${BASE_LOCK_PATH}"
            return $?
        else
            # lock is valid and OTHERPID is active - exit, we're locked!
            echo "lock failed, PID ${OTHER_PID} is active" >&2
            exit ${ENO_LOCKFAIL}
        fi
    fi
    return 0
} # lock()

# Unlock the system.
# 
# @return unlock (rm) error code.
function unlock {
    test -d "${LOCK_PATH}" && rm -r "${LOCK_PATH}" &>'/dev/null'
    return $?
} # unlock()

#######################################################################################
#######################################################################################
#######################################################################################
# Include from /usr/share/doc/bash-doc/examples/functions/getoptx.bash of package bash-doc.
#######################################################################################
#######################################################################################
#######################################################################################
function getoptex()
{
  let $# || return 1
  local optlist="${1#;}"
  let OPTIND || OPTIND=1
  [ $OPTIND -lt $# ] || return 1
  shift $OPTIND
  if [ "$1" != "-" ] && [ "$1" != "${1#-}" ]
  then OPTIND=$[OPTIND+1]; if [ "$1" != "--" ]
  then
    local o
    o="-${1#-$OPTOFS}"
    for opt in ${optlist#;}
    do
      OPTOPT="${opt%[;.:]}"
      unset OPTARG
      local opttype="${opt##*[^;:.]}"
      [ -z "$opttype" ] && opttype=";"
      if [ ${#OPTOPT} -gt 1 ]
      then # long-named option
        case $o in
          "--$OPTOPT")
            if [ "$opttype" != ":" ]; then return 0; fi
            OPTARG="$2"
            if [ -z "$OPTARG" ];
            then # error: must have an agrument
              let OPTERR && echo "$0: error: $OPTOPT must have an argument" >&2
              OPTARG="$OPTOPT";
              OPTOPT="?"
              return 1;
            fi
            OPTIND=$[OPTIND+1] # skip option's argument
            return 0
          ;;
          "--$OPTOPT="*)
            if [ "$opttype" = ";" ];
            then  # error: must not have arguments
              let OPTERR && echo "$0: error: $OPTOPT must not have arguments" >&2
              OPTARG="$OPTOPT"
              OPTOPT="?"
              return 1
            fi
            OPTARG=${o#"--$OPTOPT="}
            return 0
          ;;
        esac
      else # short-named option
        case "$o" in
          "-$OPTOPT")
            unset OPTOFS
            [ "$opttype" != ":" ] && return 0
            OPTARG="$2"
            if [ -z "$OPTARG" ]
            then
              echo "$0: error: -$OPTOPT must have an argument" >&2
              OPTARG="$OPTOPT"
              OPTOPT="?"
              return 1
            fi
            OPTIND=$[OPTIND+1] # skip option's argument
            return 0
          ;;
          "-$OPTOPT"*)
            if [ $opttype = ";" ]
            then # an option with no argument is in a chain of options
              OPTOFS="$OPTOFS?" # move to the next option in the chain
              OPTIND=$[OPTIND-1] # the chain still has other options
              return 0
            else
              unset OPTOFS
              OPTARG="${o#-$OPTOPT}"
              return 0
            fi
          ;;
        esac
      fi
    done
    echo "Error : invalid option : '${o}'." >&2
    usage
    exit 1
  fi; fi
  OPTOPT="?"
  unset OPTARG
  return 1
}
function optlistex
{
  local l="$1"
  local m # mask
  local r # to store result
  while [ ${#m} -lt $[${#l}-1] ]; do m="$m?"; done # create a "???..." mask
  while [ -n "$l" ]
  do
    r="${r:+"$r "}${l%$m}" # append the first character of $l to $r
    l="${l#?}" # cut the first charecter from $l
    m="${m#?}"  # cut one "?" sign from m
    if [ -n "${l%%[^:.;]*}" ]
    then # a special character (";", ".", or ":") was found
      r="$r${l%$m}" # append it to $r
      l="${l#?}" # cut the special character from l
      m="${m#?}"  # cut one more "?" sign
    fi
  done
  echo $r
}
function getopt()
{
  local optlist=`optlistex "$1"`
  shift
  getoptex "$optlist" "$@"
  return $?
}
#######################################################################################
#######################################################################################
#######################################################################################



# Check for binaries presence
check_binary "basename" "coreutils"
check_binary "dirname" "coreutils"
check_binary "mktemp" "mktemp"
check_binary "sed" "sed"
check_binary "avconv" "libav-tools"
check_binary "parallel" "parallel"
check_binary "eyeD3" "eyed3"
check_binary "mediainfo" "mediainfo"
check_binary "vorbiscomment" "vorbis-tools"
check_binary "metaflac" "flac"

# Application defaults

# Compute the semaphore name based on SCRIPT_NAME. 
SEMAPHORE_NAME="${SCRIPT_NAME}"

# Export configuration for mussync-tools-convert_file function.
export INPUT_PATH="$(command pwd)"
export OUTPUT_PATH="$(command pwd)"

export INPUT_FORMAT="flac"
export OUTPUT_FORMAT="mp3"

export BITRATE="320k"

export THREADS="100%"

export AVCONV_OPTIONS=""

export SYNC_DELETE='False'

export QUIET="False"
export VERBOSE="False"

export INPUT_EXTENSION="${INPUT_FORMAT}"
export OUTPUT_EXTENSION="${OUTPUT_FORMAT}"

# Parse options using getoptex from /usr/share/doc/bash-doc/examples/functions/getoptx.bash
while getoptex "help h input-path: in: i: output-path: out: o: input-format: if: s: output-format: of: e: bitrate: b: threads: t: avconv-options: a: sync-delete delete d quiet q verbose v" "${@}"; do
  # Options debuging.
  # echo "Option <$OPTOPT> ${OPTARG:+has an arg <$OPTARG>}"

  case "${OPTOPT}" in
    'input-path' | 'in' | 'i' )
      realpath_check "${OPTARG}"
      INPUT_PATH="${REALPATH}"
      ;;

    'output-path' | 'out' | 'o' )
      realpath_check "${OPTARG}"
      OUTPUT_PATH="${REALPATH}"
      ;;

    'input-format' | 'if' | 's' )
      if [ -n "${OPTARG}" ]; then
        INPUT_FORMAT="${OPTARG}"
      fi
      ;;

    'output-format' | 'of' | 'e' )
      if [ -n "${OPTARG}" ]; then
        OUTPUT_FORMAT="${OPTARG}"
      fi
      ;;

    'bitrate' | 'b' )
      if [ -n "${OPTARG}" ]; then
        BITRATE="${OPTARG}"
      fi
      ;;

    'threads' | 't' )
      if [ -n "${OPTARG}" ]; then
        THREADS="${OPTARG}"
      fi
      ;;

    'avconv-options' | 'a' )
      if [ -n "${OPTARG}" ]; then
        AVCONV_OPTIONS="${OPTARG}"
      fi
      ;;

    'sync-delete' | 'delete' | 'd' )
      SYNC_DELETE='True'
      ;;

    'quiet' | 'q' )
      QUIET='True'
      ;;

    'verbose' | 'v' )
      VERBOSE='True'
      ;;

    'help' | 'h' | * )
      usage 0
      ;;
  esac
done

shift $[OPTIND-1]

# TODO : implement a less basic extension detection based on format.
export INPUT_EXTENSION="${INPUT_FORMAT}"
export OUTPUT_EXTENSION="${OUTPUT_FORMAT}"

# Specific needs for some output formats/
case "${OUTPUT_FORMAT}" in
  'ogg' )
    # Set vorbis as default codec for ogg.
    AVCONV_OPTIONS="${AVCONV_OPTIONS} -codec:a libvorbis"
    ;;

  '*' )
    # Do nothing.
    ;;
esac

## Lock output path for this script.
lock "${OUTPUT_PATH}"

###############################
#
# Convert input files to output format.
#
################################

command find "${INPUT_PATH}" -type 'f' -iname "*.${INPUT_EXTENSION}" -print0 \
  | command parallel --jobs ${THREADS} --null 'mussync-tools-convert_file'


###############################
#
# Check for removed input files.
#
################################
if [ "${SYNC_DELETE}" = 'True' ]; then
  command find "${OUTPUT_PATH}" -type 'f' -iname "*.${OUTPUT_EXTENSION}" \
    | while read OUTPUT_FILE; do

    ## Build input file path based on output file path.
    OUTPUT_FILE_PATH="$(command dirname "${OUTPUT_FILE}")"
    INPUT_FILE_PATH="$(command echo "${OUTPUT_FILE_PATH}" | sed -e "s|^${OUTPUT_PATH}|${INPUT_PATH}|")"
    SHORT_PATH="$(command echo "${OUTPUT_FILE_PATH}" | sed -e "s|^${OUTPUT_PATH}||")"

    OUTPUT_FILENAME="$(command basename "${OUTPUT_FILE}")"
    INPUT_FILENAME="${OUTPUT_FILENAME//\.${OUTPUT_EXTENSION}/.${INPUT_EXTENSION}}"

    INPUT_FILE="${INPUT_FILE_PATH}/${INPUT_FILENAME}"

    SHORT_INPUT_FILE="${SHORT_PATH}/${INPUT_FILENAME}"
    SHORT_OUTPUT_FILE="${OUTPUT_FILENAME}"

    ## Check for input file existance.
    if [ ! -e "${INPUT_FILE}" ]; then

      ## Input file does not seems to exists.
      ## double check using find with case insensitive search.
      if [ -z "$(command find "${INPUT_FILE_PATH}" -maxdepth 1 -type 'f' -iname "${INPUT_FILENAME}")" ]; then

        # Input file not found. Removing output file.
        test "${QUIET}" != 'True' && echo -n "File '${SHORT_INPUT_FILE}' disappeared.
  -> Removing '${SHORT_OUTPUT_FILE}'... "
        command test -e "${OUTPUT_FILE}" && command rm "${OUTPUT_FILE}"

        if [ -e "${OUTPUT_FILE}" ]; then
          test "${QUIET}" != 'True' && echo "Failed."
        else
          test "${QUIET}" != 'True' && echo "Done."
        fi

      fi

    fi
  done
fi

unlock
exit 0

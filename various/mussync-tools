#!/bin/bash
#
# Music library convert and sync.
#
# For suggestion and bug reports, please contact
# Pierre-Yves Landuré <pierre-yves dot landure at biapy dot fr>
#
# Thanks to m31z0nyx on irc.freenode.net #debian-facile for his help i
# finding a script name.
#
# Thanks to GNU Parallel.
#  O. Tange (2011): GNU Parallel - The Command-Line Power Tool,
#  ;login: The USENIX Magazine, February 2011:42-47.
#
VERSION="1.2.2"

SCRIPT_NAME="$(command basename "${0}")"

# Print this script help.
function usage {
  command echo "Music library convert and sync v${VERSION}
This tool convert a input (Flac) music library to an output (MP3) music folder
and keep the folder structure.

Usage :

  ${SCRIPT_NAME} [ --help ] [ --quiet ] [ --verbose ]
      [ --input-path='/path/to/original/library' ]
      [ --output-path='/path/to/converted/library' ]
      [ --input-format='*' ] [ --output-format='mp3' ]
      [ --bitrate='320k' | --quality=5 ]
      [ --sync-delete ] [ --copy-all ]
      [ --avconv-options='--more --avconv --options' ]

  Available options are :
    * --help | -h                   : Display this message.
    * --input-path  | --in  | -i    : Set the path to the source library
                                      (default to current)
    * --output-path | --out | -o    : Set the path to the target library
                                      (default to current)
    * --input-format  | --if        : Set the input format. Default to *.
    * --output-format | --of | -e   : Set the output format. Default to MP3.
    * --bitrate | -b                : Set the CBR bitrate. Default to 192k.
                                      Trigger CBR encoding.
    * --quality | -q                : Set the VBR quality. Default to 6.
                                      0 is the lowest, 9 the highest.
                                      Trigger VBR encoding (default).
    * --sync-delete | --delete | -d : Propagate file deletion from input
                                      library to output library.
                                      Any output file without equivalence in
                                      input library is deleted.
    * --copy-all | --copy | -c      : Copy non audio files found in source
                                      library to target library.
    * --avconv-options | -a         : Additionnal options for avconv.
                                      See avconv man page.
    * --threads | -t                : Threads number.
                                      Default to 1 thread by CPU.
    * --quiet | --silent | -s       : Disable almost all outputs.
    * --verbose | -v                : Enable debug outputs.

  Completly supported formats are :
    * MP3 (mp3)
    * Flac (flac)
    * Ogg/Vorbis (ogg)

    When converting from/to this formats, metadatas an cover art will be
    transfered to the created files.
"

  test -n "${1}" && exit ${1}
} # usage



# Get the absolute path for a file or directory.
#
# @param string $path A relative path.
#
# @return ${REALPATH} A absolute path.
REALPATH=''
function realpath {
  # declare -g REALPATH=''
  REALPATH=''

  command test ${#} -ne 1 && exit 1

  case "$(command uname)" in
    'Linux' )
      REALPATH="$(command readlink -f "${1}")"
      ;;
    'Darwin' )
      REALPATH="$(command stat -f '%N' "${1}")"
      ;;
    * )
      REALPATH="$(command realpath "${1}")"
      ;;
  esac
} # realpath



# Get the absolute path for a file or directory and check the file existance.
# If the file does not exists, display an error message and exit the script.
#
# @param string $path A relative path.
#
# @return ${REALPATH} A absolute path or an empty string if file don't exists.
REALPATH=''
function realpath_check {
  # declare -g REALPATH=''
  REALPATH=''

  command test ${#} -ne 1 && exit 1

  realpath "${1}"

  if [ -n "${REALPATH}" -a ! -e "${REALPATH}" ]; then
    REALPATH=""
  fi

  if [ -z "${REALPATH}" ]; then
    echo "Error: File '${1}' does not exists." >&2
    exit 1
  fi
} # realpath_check



# Check if a binary is present
#
# @param string $binary The binaries to check, separated by ;.
# @param string $package The package the binary come from.
#
# @return Exit with error if the binary is missing.
BINARY=''
function check_binary {
  # declare -g BINARY=''
  BINARY=''

  command test ${#} -ne 2 && exit 1

  local PRIMARY="$(echo "${1}" | command cut -d ';' -f 1)"
  local BINARIES="";

  IFS=';' command read -a BINARIES <<< "${1}"

  # Test the binary presence.
  for BINARY in ${BINARIES[@]}; do
    if [ -n "$(command -v "${BINARY}")" ]; then
      return 0
    fi
  done

  echo "Error: '${PRIMARY}' is missing. Please install package '${2}'." >&2
  exit 1
} # check_binary



# Transfert cover art from input file to output file.
# Reset all cover art in output file.
#
# @param string $input_file The audio input file.
# @param string $output_file The audio output file.
#
# @return Exit with error if conversion failed.
function transfert_images {
  command test ${#} -ne 2 && exit 1

  local INPUT_FILE="${1}"
  local OUTPUT_FILE="${2}"

  # Detect base64 command line based on OS.
  case "$(command uname)" in
    'Darwin' )
      local BASE64="$(command -v base64) --break=0"
      local EYE3D_REMOVE_ALL="${EYED3} --remove-all-images"
      ;;
    'Linux' | * )
      local BASE64="$(command -v base64) --wrap=0"
      local EYE3D_REMOVE_ALL="${EYED3} --remove-images"
      ;;
  esac



  # Detect if input file has cover art.
  local INPUT_FILE_HAS_COVER="$(command mediainfo --Inform="General;%Cover%" "${INPUT_FILE}")"
  local METADATA_BLOCK_PICTURE='False'

  if [ "${INPUT_FILE_HAS_COVER}" != 'Yes' \
      -a -n "$(command mediainfo "${INPUT_FILE}" | command grep '^metadata_block_picture')" ]; then
    INPUT_FILE_HAS_COVER='Yes'
    METADATA_BLOCK_PICTURE='True'
  fi

  if [ "${INPUT_FILE_HAS_COVER}" = 'Yes' ]; then
    test "${QUIET}" != 'True' && echo -n " -> Transfering cover art to $(command basename "${OUTPUT_FILE}")... "

    # Detect Cover MIME type.
    local IMAGE_MIME_TYPE="$(command mediainfo --Inform="General;%Cover_Mime%" "${INPUT_FILE}")"
    local IMAGE_EXTENSION="$(echo "${IMAGE_MIME_TYPE}" | command cut -d '/' -f 2)"

    if [ -z "${IMAGE_EXTENSION}" ]; then
      if [ "${METADATA_BLOCK_PICTURE}" != 'True' ]; then
        # Unable to determine cover mime type.
        test "${QUIET}" != 'True' && echo "Failed (MIME type unsupported (${IMAGE_MIME_TYPE}))."
        return 1
      fi
    else
      # Create image temporary file. 
      local IMAGE_PATH="$(command mktemp -t "tmp.XXXXXXXXXX")"
      command mv "${IMAGE_PATH}" "${IMAGE_PATH}.${IMAGE_EXTENSION}"
      IMAGE_PATH="${IMAGE_PATH}.${IMAGE_EXTENSION}"
    fi

    # Detect input file format and audio format.
    local INPUT_FILE_FORMAT="$(command mediainfo --Inform="General;%Format%" "${INPUT_FILE}")"
    local INPUT_FILE_AUDIO_FORMAT="$(command mediainfo --Inform="Audio;%Format%" "${INPUT_FILE}")"

    test "${QUIET}" != 'True' && echo -n "Extracting... "

    case "${INPUT_FILE_FORMAT}" in

      'FLAC' )
        # File is Flac

        # List IMAGE metadata blocs.
        # Assume first bloc is cover art.
        local BLOCK_NUMBER="$(command metaflac --list --block-type='PICTURE' "${INPUT_FILE}" \
            | command grep --max-count=1 '^METADATA block' \
            | command sed -e 's/^.*#//')"

        # Determine cover image MIME type.
        IMAGE_MIME_TYPE="$(command metaflac --block-number="${BLOCK_NUMBER}" --list "${INPUT_FILE}" \
            | command grep "MIME type:" \
            | command sed -e 's/.*MIME type: //g')"

        # Extract cover image from file.
        command metaflac --block-number="${BLOCK_NUMBER}" \
            --export-picture-to="${IMAGE_PATH}" "${INPUT_FILE}"
        ;;

      'MPEG Audio' )
        # File is MP3
        local MP3_IMAGE_PATH="$(command mktemp -d -t "tmp.XXXXXXXXXX")"

        if [ "${VERBOSE}" = 'True' ]; then
          command ${EYED3} --write-images="${MP3_IMAGE_PATH}" "${INPUT_FILE}"
        else
          command ${EYED3} --write-images="${MP3_IMAGE_PATH}" "${INPUT_FILE}" > '/dev/null' 2>&1
        fi

        if [ -e "${MP3_IMAGE_PATH}/FRONT_COVER.${IMAGE_EXTENSION}" ]; then
          command mv "${MP3_IMAGE_PATH}/FRONT_COVER.${IMAGE_EXTENSION}" "${IMAGE_PATH}"
        fi

        command rm -r "${MP3_IMAGE_PATH}"
        ;;

      'OGG' )
        # File is an OGG container.
        case "${INPUT_FILE_AUDIO_FORMAT}" in

          'Vorbis' )
            # File is OGG Vorbis.

            local IMAGE_WITH_HEADERS_PATH="$(command mktemp -t "tmp.XXXXXXXXXX")"

            command vorbiscomment --list --raw "${INPUT_FILE}" \
                | command grep --max-count=1 '^metadata_block_picture=' \
                | command sed -e 's/^metadata_block_picture=//' \
                | command ${BASE64} --decode \
              > "${IMAGE_WITH_HEADERS_PATH}"

            # Fetch data lengths.
            local MIME_LENGTH="$(command dd skip=4 count=4 bs=1 \
                if="${IMAGE_WITH_HEADERS_PATH}" 2>'/dev/null' \
                | command xxd -p -g0 \
                | command xargs -IHEX printf "%d" '0xHEX')"

            IMAGE_MIME_TYPE="$(command dd skip=8 count="${MIME_LENGTH}" bs=1 \
                if="${IMAGE_WITH_HEADERS_PATH}" 2>'/dev/null')"

            # Now we try to detect extension and create the temporary image file.
            IMAGE_EXTENSION="$(echo "${IMAGE_MIME_TYPE}" | command cut -d '/' -f 2)"
            if [ -z "${IMAGE_EXTENSION}" ]; then
              # Unable to determine cover mime type.
              test -e "${IMAGE_WITH_HEADERS_PATH}" && command rm "${IMAGE_WITH_HEADERS_PATH}"

              test "${QUIET}" != 'True' && echo "Failed (MIME type unsupported (${IMAGE_MIME_TYPE}))."
              return 1
            fi

            IMAGE_PATH="$(command mktemp -t "tmp.XXXXXXXXXX")"
            command mv "${IMAGE_PATH}" "${IMAGE_PATH}.${IMAGE_EXTENSION}"
            IMAGE_PATH="${IMAGE_PATH}.${IMAGE_EXTENSION}"

            local DESCRIPTION_SKIP="$((8 + ${MIME_LENGTH}))"
            local DESCRIPTION_LENGTH="$(command dd skip=${DESCRIPTION_SKIP} count=4 bs=1 \
                if="${IMAGE_WITH_HEADERS_PATH}" 2>'/dev/null' \
                | command xxd -p -g0 \
                | command xargs -IHEX printf "%d" '0xHEX')"
            local IMAGE_LENGTH_SKIP="$((${DESCRIPTION_SKIP} + ${DESCRIPTION_LENGTH} + 20))"
            local IMAGE_LENGTH="$(command dd skip=${IMAGE_LENGTH_SKIP} count=4 bs=1 \
                if="${IMAGE_WITH_HEADERS_PATH}" 2>'/dev/null' \
                | command xxd -p -g0 \
                | command xargs -IHEX printf "%d" '0xHEX')"

            local IMAGE_SKIP="$((${IMAGE_LENGTH_SKIP} + 4))"
            # Extract image.

            if [ "${VERBOSE}" = 'True' ]; then
              command dd skip=${IMAGE_SKIP} count=${IMAGE_LENGTH} bs=1 \
                  if="${IMAGE_WITH_HEADERS_PATH}" of="${IMAGE_PATH}"
            else
              command dd skip=${IMAGE_SKIP} count=${IMAGE_LENGTH} bs=1 \
                  if="${IMAGE_WITH_HEADERS_PATH}" of="${IMAGE_PATH}" 2>'/dev/null'
             fi

            # Delete vorbiscomment raw file.
            test -e "${IMAGE_WITH_HEADERS_PATH}" && command rm "${IMAGE_WITH_HEADERS_PATH}"
            ;;

          * )
            test -e "${IMAGE_PATH}" && command rm "${IMAGE_PATH}"
            test "${QUIET}" != 'True' && echo "Failed (Ogg audio encoding unsupported (${INPUT_FILE_AUDIO_FORMAT}))."
            return 1
            ;;

        esac

        ;;

      * )
        test -e "${IMAGE_PATH}" && command rm "${IMAGE_PATH}"

        test "${QUIET}" != 'True' && echo "Failed (Input file format unsupported (${INPUT_FILE_FORMAT}))."
        return 1
        ;;

    esac

    # Test if an image has been extracted from INPUT_FILE and if we have an OUTPUT_FILE.
    if [ -s "${IMAGE_PATH}" -a -e "${OUTPUT_FILE}" ]; then
      test "${QUIET}" != 'True' && echo -n "Importing... "

      # Detect output file format and audio format.
      local OUTPUT_FILE_FORMAT="$(command mediainfo --Inform="General;%Format%" "${OUTPUT_FILE}")"
      local OUTPUT_FILE_AUDIO_FORMAT="$(command mediainfo --Inform="Audio;%Format%" "${OUTPUT_FILE}")"

      case "${OUTPUT_FILE_FORMAT}" in

        'FLAC' )
          # File is Flac
          # Remove existing images.
          command metaflac --block-type='PICTURE' --dont-use-padding --remove "${OUTPUT_FILE}"
          # Insert cover image from file.
          command metaflac --import-picture-from="${IMAGE_PATH}" "${OUTPUT_FILE}"
          ;;

        'MPEG Audio' )
          # File is MP3
          if [ "${VERBOSE}" = 'True' ]; then
            # Remove existing images.
            command ${EYE3D_REMOVE_ALL} "${OUTPUT_FILE}"
            # Insert cover image from file
            command ${EYED3} --add-image="${IMAGE_PATH}:FRONT_COVER" "${OUTPUT_FILE}"
          else
            # Remove existing images.
            command ${EYE3D_REMOVE_ALL} "${OUTPUT_FILE}" > '/dev/null' 2>&1
            # Insert cover image from file
            command ${EYED3} --add-image="${IMAGE_PATH}:FRONT_COVER" "${OUTPUT_FILE}" > '/dev/null' 2>&1
          fi
          ;;

        'OGG' )
          # File is an OGG container.
          case "${OUTPUT_FILE_AUDIO_FORMAT}" in

            'Vorbis' )
              # File is OGG Vorbis.

              # Export existing comments to file.
              local COMMENTS_PATH="$(command mktemp -t "tmp.XXXXXXXXXX")"

              command vorbiscomment --list --raw "${OUTPUT_FILE}" > "${COMMENTS_PATH}"

              # Remove existing images.
              command sed -i'' -e '/^METADATA_BLOCK_PICTURE/Id' "${COMMENTS_PATH}"

              # Insert cover image from file.

              # metadata_block_picture format.
              # See: https://xiph.org/flac/format.html#metadata_block_picture

              local IMAGE_WITH_HEADER="$(command mktemp -t "tmp.XXXXXXXXXX")"
              local DESCRIPTION=""

              # Reset cache file.
              echo -n "" > "${IMAGE_WITH_HEADER}"

              # Picture type <32>.
              command printf "0: %.8x" 3 | command xxd -r -g0 \
                      >> "${IMAGE_WITH_HEADER}"
              # Mime type length <32>.
              command printf "0: %.8x" $(echo -n "${IMAGE_MIME_TYPE}" | command wc -c) \
                        | command xxd -r -g0 \
                      >> "${IMAGE_WITH_HEADER}"
              # Mime type (n * 8)
              echo -n "${IMAGE_MIME_TYPE}" >> "${IMAGE_WITH_HEADER}"
              # Description length <32>.
              command printf "0: %.8x" $(echo -n "${DESCRIPTION}" | command wc -c) \
                        | command xxd -r -g0 \
                      >> "${IMAGE_WITH_HEADER}"
              # Description (n * 8)
              echo -n "${DESCRIPTION}" >> "${IMAGE_WITH_HEADER}"
              # Picture with <32>.
              command printf "0: %.8x" 0 | command xxd -r -g0 \
                      >> "${IMAGE_WITH_HEADER}"
              # Picture height <32>.
              command printf "0: %.8x" 0 | command xxd -r -g0 \
                      >> "${IMAGE_WITH_HEADER}"
              # Picture color depth <32>.
              command printf "0: %.8x" 0 | command xxd -r -g0 \
                      >> "${IMAGE_WITH_HEADER}"
              # Picture color count <32>.
              command printf "0: %.8x" 0 | command xxd -r -g0 \
                      >> "${IMAGE_WITH_HEADER}"
              # Image file size <32>.
              command printf "0: %.8x" $(command wc -c "${IMAGE_PATH}" \
                        | command cut -d ' ' -f 1) \
                        | command xxd -r -g0 \
                      >> "${IMAGE_WITH_HEADER}"
              # Image file.
              command cat "${IMAGE_PATH}" >> "${IMAGE_WITH_HEADER}"

              echo "METADATA_BLOCK_PICTURE=$(command ${BASE64} < "${IMAGE_WITH_HEADER}")" >> "${COMMENTS_PATH}"

              # Update vorbis file comments.
              command vorbiscomment --write --raw --commentfile "${COMMENTS_PATH}" "${OUTPUT_FILE}"

              # Delete cache file.
              test -e "${IMAGE_WITH_HEADER}" && command rm "${IMAGE_WITH_HEADER}"
              # Delete comments file.
              test -e "${COMMENTS_PATH}" && command rm "${COMMENTS_PATH}"
              ;;

            * )
              test -e "${IMAGE_PATH}" && command rm "${IMAGE_PATH}"
              test "${QUIET}" != 'True' && echo "Failed (Ogg audio encoding unsupported (${OUTPUT_FILE_AUDIO_FORMAT}))."
              return 1
              ;;

          esac

          ;;

        * )
          test -e "${IMAGE_PATH}" && command rm "${IMAGE_PATH}"

          test "${QUIET}" != 'True' && echo "Failed (Output file format unsupported (${OUTPUT_FILE_FORMAT}))."
          return 1
          ;;

      esac
 
    fi

    test -e "${IMAGE_PATH}" && command rm "${IMAGE_PATH}"


    test "${QUIET}" != 'True' && echo "Done."
  fi

  return 0
} # transfert_images()

export -f 'transfert_images'



# Convert an audio file from source library to target library.
#
# @param string $input_file The audio input file.
#
# @return Exit with error if conversion failed.
function convert_file {
  command test ${#} -ne 1 && exit 1

  local INPUT_FILE="${1}"

  ## Build output file path based on input file path.
  local INPUT_FILE_PATH="$(command dirname "${INPUT_FILE}")"
  local OUTPUT_FILE_PATH="$(command echo "${INPUT_FILE_PATH}" | sed -e "s|^${INPUT_PATH}|${OUTPUT_PATH}|")"
  local SHORT_PATH="$(command echo "${INPUT_FILE_PATH}" | sed -e "s|^${INPUT_PATH}||")"

  local INPUT_FILENAME="$(command basename "${INPUT_FILE}")"
  local OUTPUT_FILENAME="$(command echo -n "${INPUT_FILENAME}" \
        | command sed -e "s/\.[^\.]*$/\.${OUTPUT_EXTENSION}/")"
  local INPUT_FILE_MIMETYPE="$(command file --brief --mime-type "${INPUT_FILE}")"

  # Detect input extension
  local INPUT_FILE_EXTENSION="$(command echo -n "${INPUT_FILENAME}" \
        | command sed -e 's/^.*\.\([^\.]*\)$/\1/')"

  local OUTPUT_FILE="${OUTPUT_FILE_PATH}/${OUTPUT_FILENAME}"

  local SHORT_INPUT_FILE="${SHORT_PATH}/${INPUT_FILENAME}"
  local SHORT_OUTPUT_FILE="${OUTPUT_FILENAME}"

  # Generate a temporary filename for processing cache.
  # Use the same extension to make sure format detection work properly.

  local OUTPUT_TEMP_FILE="$(command mktemp -t "tmp.XXXXXXXXXX")"
  command mv "${OUTPUT_TEMP_FILE}" "${OUTPUT_TEMP_FILE}.${OUTPUT_EXTENSION}"
  OUTPUT_TEMP_FILE="${OUTPUT_TEMP_FILE}.${OUTPUT_EXTENSION}"

  # Test if input file is an audio file.
  if [ "${INPUT_FILE_MIMETYPE}" != 'application/ogg' \
      -a "$(command echo -n "${INPUT_FILE_MIMETYPE}" \
            | cut -d '/' -f 1)" != 'audio' ]; then
    # Input file is not an audio file.
    test "${QUIET}" != 'True' && echo -n "'${SHORT_INPUT_FILE}' is not a audio file... "

    # Update computed values.
    OUTPUT_FILENAME="${INPUT_FILENAME}"
    OUTPUT_FILE="${OUTPUT_FILE_PATH}/${OUTPUT_FILENAME}"
    SHORT_OUTPUT_FILE="${OUTPUT_FILENAME}"

    local COPY_NEEDED='FALSE'

    if [ "${COPY_ALL}" = 'True' ]; then

      if [ ! -e "${OUTPUT_FILE}" ]; then
        COPY_NEEDED='True'
        test "${QUIET}" != 'True' && echo "Copying."
      else
        # Check if output file is older than input file.
        if [ "${INPUT_FILE}" -nt "${OUTPUT_FILE}" ]; then
          test "${QUIET}" != 'True' && echo "Updating."
          COPY_NEEDED='True'
        else
          test "${QUIET}" != 'True' && echo "Skipping."
        fi
      fi
    else
      test "${QUIET}" != 'True' && echo "Skipping."
    fi

    if [ "${COPY_NEEDED}" = 'True' ]; then
      command cp -a "${INPUT_FILE}" "${OUTPUT_FILE}"
      return $?
    fi

    return 0
  fi


  local CONVERSION_NEEDED='False'
  # Check if output file already exists.
  if [ "${INPUT_EXTENSION}" = '*' \
      -o "${INPUT_EXTENSION}" = "${INPUT_FILE_EXTENSION}" ]; then
    if [ ! -e "${OUTPUT_FILE}" ]; then
      CONVERSION_NEEDED='True'
    else
      test "${QUIET}" != 'True' && echo -n "'${SHORT_OUTPUT_FILE}' exists... "

      # Check if output file is older than input file.
      if [ "${INPUT_FILE}" -nt "${OUTPUT_FILE}" ]; then
        test "${QUIET}" != 'True' && echo "Updating."
        CONVERSION_NEEDED='True'
      else
        test "${QUIET}" != 'True' && echo "Skipping."
      fi
    fi
  else
    # Found file has not the correct extension.
    test "${QUIET}" != 'True' && echo "'${SHORT_INPUT_FILE}' is not in source format... Skipping."
  fi

  if [ "${CONVERSION_NEEDED}" = 'True' ]; then
    if [ -e "${INPUT_FILE}" ]; then
      command mkdir -p "${OUTPUT_FILE_PATH}"

      if [ -d "${OUTPUT_FILE_PATH}" ]; then
        # Remove output file if it already exists.
        if [ -e "${OUTPUT_FILE}" ]; then
          command rm "${OUTPUT_FILE}"
        fi

        if [ "${INPUT_FORMAT}" = "${OUTPUT_FORMAT}" ]; then
          # Copy input to output (format is the same).
          test "${QUIET}" != 'True' && echo -n "Copying '${SHORT_INPUT_FILE}' to '${SHORT_OUTPUT_FILE}'... "
          command cp "${INPUT_FILE}" "${OUTPUT_FILE}"
        else
          # Convert input to output
          test "${QUIET}" != 'True' && echo -n "Converting '${SHORT_INPUT_FILE}' to '${SHORT_OUTPUT_FILE}'... "

          local LOG_LEVEL='quiet'
          if [ "${VERBOSE}" = 'True' ]; then
            LOG_LEVEL='debug'
          fi

          local ENCODING_OPTIONS=''
          # Specific options for encoding mode.
          case "${ENCODING_MODE}" in
            'CBR' )
              # Constant bitrate selected.
              ENCODING_OPTIONS="-b:a ${ENCODING_BITRATE}"
             ;;

            'VBR' | * )
              # Variable bitrate selected. Default.
              ENCODING_OPTIONS="-q:a ${ENCODING_QUALITY}"
              ;;
          esac

          local MAP_METADATA=' 0:g'
          # Specific needs for some input formats/
          case "${INPUT_FILE_MIMETYPE}" in
            'application/ogg' )
              # Get input metadata from first audio stream and direct it to global.
              # See https://bugs.kde.org/show_bug.cgi?id=306895
              MAP_METADATA=' 0:s:0'
              ;;

            * )
              # Do nothing.
              # MAP_METADATA=' 0:g'
              ;;
          esac

          # Specific needs for some output formats/
          local OUTPUT_OPTIONS="-f ${OUTPUT_FORMAT}"
          case "${OUTPUT_FORMAT}" in
            'flac' )
              # No encoding options needed.
              ENCODING_OPTIONS=""
              # OUTPUT_OPTIONS="-f ${OUTPUT_FORMAT}"
              ;;

            'ogg' | 'vorbis' )
              # Set vorbis as default codec for ogg.
              OUTPUT_OPTIONS="-codec:a libvorbis -f ogg"
              # Map input metadata to all audio streams in ogg container.
              # See https://bugs.kde.org/show_bug.cgi?id=306895
              if [ "${INPUT_FILE_MIMETYPE}" = 'application/ogg' ]; then
                MAP_METADATA=" 0:s:0"
              else
                MAP_METADATA=":s:a 0:s:0"
              fi
              ;;

            'mp3' )
              # Force libmp3lame use.
              OUTPUT_OPTIONS="-codec:a libmp3lame ${OUTPUT_OPTIONS}"
              ;;

            * )
              # Do nothing.
              # MAP_METADATA="${MAP_METADATA}"
              # OUTPUT_OPTIONS="-f ${OUTPUT_FORMAT}"
              ;;
          esac

          # Fix for mp3 cbr format, harmless for other formats.
          # Write output on pipe and then directed to file.
          # See: http://ffmpeg.zeranoe.com/forum/viewtopic.php?f=7&t=377
          #
          # Note: log output is alway on 2. avconv keep 1 empty.
          if ! command ${AVCONV} -i "${INPUT_FILE}" \
                     -vn -sn \
                    -map_metadata${MAP_METADATA} \
                    -loglevel "${LOG_LEVEL}" \
                    ${AVCONV_OPTIONS} \
                    ${OUTPUT_OPTIONS} \
                    ${ENCODING_OPTIONS} \
                    - > "${OUTPUT_TEMP_FILE}"; then
            test "${QUIET}" != 'True' && echo "Failed."
            test -e "${OUTPUT_TEMP_FILE}" && command rm "${OUTPUT_TEMP_FILE}"
            test -e "${OUTPUT_FILE}" && command rm "${OUTPUT_FILE}"

            return 1
          else
            test "${QUIET}" != 'True' && echo "Done."

            # Test if fix for MP3 VBR is needed.
            # See: http://ffmpeg.zeranoe.com/forum/viewtopic.php?f=7&t=377
            if [ "${OUTPUT_FORMAT}" = 'mp3' -a "${ENCODING_MODE}" != 'CBR' ]; then
              local OUTPUT_FILE_AUDIO_FORMAT=""
              local VBRFIX_COUNT=0
              while [ "${OUTPUT_FILE_AUDIO_FORMAT}" != 'MPEG Audio' ]; do

                # 5 tries maximum.
                if [ ${VBRFIX_COUNT} -gt 5 ]; then
                  test -e "${OUTPUT_TEMP_FILE}" && command rm "${OUTPUT_TEMP_FILE}"
                  test -e "${OUTPUT_FILE}" && command rm "${OUTPUT_FILE}"

                  test "${QUIET}" != 'True' && echo "Failed. Removing output file."
                  return 1
                  break;
                fi

                if [ ${VBRFIX_COUNT} -gt 0 ]; then
                  test "${QUIET}" != 'True' && echo "Failed."
                fi

                command let VBRFIX_COUNT+=1
                test "${QUIET}" != 'True' && echo -n " -> Fixing '${SHORT_OUTPUT_FILE}' VBR header (try ${VBRFIX_COUNT})..."

                # Output file is MP3 and VBR. Apply header fix.
                if [ "${VERBOSE}" = 'True' ]; then
                  command vbrfix "${OUTPUT_TEMP_FILE}" "${OUTPUT_FILE}"
                else
                  command vbrfix "${OUTPUT_TEMP_FILE}" "${OUTPUT_FILE}" >'/dev/null' 2>&1
                fi

                # Check that vbrfix has done his job correctly.
                OUTPUT_FILE_AUDIO_FORMAT="$(command mediainfo --Inform="Audio;%Format%" "${OUTPUT_FILE}")"
              done

              test "${QUIET}" != 'True' -a -e "${OUTPUT_FILE}" && echo "Done."
            else
              # Nothing to do but rename the file.
              command mv "${OUTPUT_TEMP_FILE}" "${OUTPUT_FILE}"
            fi

            # Delete temporary file if it is still present.
            test -e "${OUTPUT_TEMP_FILE}" && command rm "${OUTPUT_TEMP_FILE}"

            # Fetch cover art from input file.
            if [ -e "${INPUT_FILE}" -a -e "${OUTPUT_FILE}" ]; then
              transfert_images "${INPUT_FILE}" "${OUTPUT_FILE}"
            fi
          fi
        fi
      else
        echo "Error: unable to create folder '${OUTPUT_FILE_PATH}'." >&2

        return 1
      fi
    else
      test "${QUIET}" != 'True' && echo "'${INPUT_FILE}' not found... Skipping."
    fi
  fi

  return 0
} # convert_file

# Export convert_file for usage with Parallel / Sem.
export -f 'convert_file'


#######################################################################################
#######################################################################################
#######################################################################################
# Include from http://wiki.grzegorz.wierzowiecki.pl/code:mutex-in-bash
#######################################################################################
#######################################################################################
#######################################################################################
# lock dirs/files
LOCK_DIR=".${SCRIPT_NAME}.lock"
PID_FILE="${SCRIPT_NAME}.pid"

# exit codes and text for them - additional features nobody needs :-)
ENO_SUCCESS=0; ETXT[0]="ENO_SUCCESS"
ENO_GENERAL=1; ETXT[1]="ENO_GENERAL"
ENO_LOCKFAIL=2; ETXT[2]="ENO_LOCKFAIL"
ENO_RECVSIG=3; ETXT[3]="ENO_RECVSIG"

BASE_LOCK_PATH="/var/lock"
LOCK_PATH="${BASE_LOCK_PATH}/${LOCK_DIR}"

# Lock the system.
#
# @param string $base_lock_path Optionnal custom path to lock file.
#                               Default to /var/lock.
# 
# @return unlock (rm) error code.
function lock {
    if [ -n "${1}" ]; then
      realpath_check "${1}"
      BASE_LOCK_PATH="${REALPATH}"
    fi

    LOCK_PATH="${BASE_LOCK_PATH}/${LOCK_DIR}"
    local PID_PATH="${LOCK_PATH}/${PID_FILE}"

    if mkdir "${LOCK_PATH}" &>'/dev/null'; then
        # lock succeeded, install signal handlers before storing the PID just in case
        # storing the PID fails
        trap 'ECODE=$?;
            echo "[${SCRIPT_NAME}] Removing lock. Exit: ${ETXT[ECODE]}($ECODE)" >&2
            test -d "${LOCK_PATH}" && rm -rf "${LOCK_PATH}"' 0

        # lock succeeded, store the PID
        echo "$$" >"${PID_PATH}"

        # the following handler will exit the script on receiving these signals
        # the trap on "0" (EXIT) from above will be triggered by this trap's
        # "exit" command!
        trap 'echo "[${SCRIPT_NAME}] Killed by a signal." >&2
              exit ${ENO_RECVSIG}' 1 2 3 15

        return ${ENO_SUCCESS}
    else
        # lock failed, now check if the other PID is alive
        OTHER_PID="$(command cat "${PID_PATH}" 2>'/dev/null')"

        # if cat wasn't able to read the file anymore, another instance probably is
        # about to remove the lock -- exit, we're *still* locked
        # Thanks to Grzegorz Wierzowiecki for pointing this race condition out on
        # http://wiki.grzegorz.wierzowiecki.pl/code:mutex-in-bash
        if [ ${?} != 0 ]; then
            # Pid file does not exists - probably directory is beeing deleted
            exit ${ENO_LOCKFAIL}
        fi

        if ! kill -0 ${OTHER_PID} &>'/dev/null'; then
            # lock is stale, remove it and restart
            unlock
            lock "${BASE_LOCK_PATH}"
            return $?
        else
            # lock is valid and OTHERPID is active - exit, we're locked!
            echo "lock failed, PID ${OTHER_PID} is active" >&2
            exit ${ENO_LOCKFAIL}
        fi
    fi
    return 0
} # lock()

# Unlock the system.
# 
# @return unlock (rm) error code.
function unlock {
    test -d "${LOCK_PATH}" && rm -r "${LOCK_PATH}" &>'/dev/null'
    return $?
} # unlock()

#######################################################################################
#######################################################################################
#######################################################################################
# Include from /usr/share/doc/bash-doc/examples/functions/getoptx.bash of package bash-doc.
#######################################################################################
#######################################################################################
#######################################################################################
function getoptex()
{
  let $# || return 1
  local optlist="${1#;}"
  let OPTIND || OPTIND=1
  [ $OPTIND -lt $# ] || return 1
  shift $OPTIND
  if [ "$1" != "-" ] && [ "$1" != "${1#-}" ]
  then OPTIND=$[OPTIND+1]; if [ "$1" != "--" ]
  then
    local o
    o="-${1#-$OPTOFS}"
    for opt in ${optlist#;}
    do
      OPTOPT="${opt%[;.:]}"
      unset OPTARG
      local opttype="${opt##*[^;:.]}"
      [ -z "$opttype" ] && opttype=";"
      if [ ${#OPTOPT} -gt 1 ]
      then # long-named option
        case $o in
          "--$OPTOPT")
            if [ "$opttype" != ":" ]; then return 0; fi
            OPTARG="$2"
            if [ -z "$OPTARG" ];
            then # error: must have an agrument
              let OPTERR && echo "$0: error: $OPTOPT must have an argument" >&2
              OPTARG="$OPTOPT";
              OPTOPT="?"
              return 1;
            fi
            OPTIND=$[OPTIND+1] # skip option's argument
            return 0
          ;;
          "--$OPTOPT="*)
            if [ "$opttype" = ";" ];
            then  # error: must not have arguments
              let OPTERR && echo "$0: error: $OPTOPT must not have arguments" >&2
              OPTARG="$OPTOPT"
              OPTOPT="?"
              return 1
            fi
            OPTARG=${o#"--$OPTOPT="}
            return 0
          ;;
        esac
      else # short-named option
        case "$o" in
          "-$OPTOPT")
            unset OPTOFS
            [ "$opttype" != ":" ] && return 0
            OPTARG="$2"
            if [ -z "$OPTARG" ]
            then
              echo "$0: error: -$OPTOPT must have an argument" >&2
              OPTARG="$OPTOPT"
              OPTOPT="?"
              return 1
            fi
            OPTIND=$[OPTIND+1] # skip option's argument
            return 0
          ;;
          "-$OPTOPT"*)
            if [ $opttype = ";" ]
            then # an option with no argument is in a chain of options
              OPTOFS="$OPTOFS?" # move to the next option in the chain
              OPTIND=$[OPTIND-1] # the chain still has other options
              return 0
            else
              unset OPTOFS
              OPTARG="${o#-$OPTOPT}"
              return 0
            fi
          ;;
        esac
      fi
    done
    echo "Error : invalid option : '${o}'." >&2
    usage
    exit 1
  fi; fi
  OPTOPT="?"
  unset OPTARG
  return 1
}
function optlistex
{
  local l="$1"
  local m # mask
  local r # to store result
  while [ ${#m} -lt $[${#l}-1] ]; do m="$m?"; done # create a "???..." mask
  while [ -n "$l" ]
  do
    r="${r:+"$r "}${l%$m}" # append the first character of $l to $r
    l="${l#?}" # cut the first charecter from $l
    m="${m#?}"  # cut one "?" sign from m
    if [ -n "${l%%[^:.;]*}" ]
    then # a special character (";", ".", or ":") was found
      r="$r${l%$m}" # append it to $r
      l="${l#?}" # cut the special character from l
      m="${m#?}"  # cut one more "?" sign
    fi
  done
  echo $r
}
function getopt()
{
  local optlist=`optlistex "$1"`
  shift
  getoptex "$optlist" "$@"
  return $?
}
#######################################################################################
#######################################################################################
#######################################################################################



# Check for binaries presence
check_binary "basename" "coreutils"
check_binary "dirname" "coreutils"
check_binary "mktemp" "mktemp"
check_binary "sed" "sed"
check_binary "avconv;ffmpeg" "libav-tools"
export AVCONV="${BINARY}"
check_binary "parallel" "parallel"
PARALLEL="${BINARY}"
check_binary "eyeD3;eyeD3-2.7;eyeD3-2.6" "eyed3"
export EYED3="${BINARY}"
check_binary "mediainfo" "mediainfo"
check_binary "vorbiscomment" "vorbis-tools"
check_binary "metaflac" "flac"
check_binary "vbrfix" "vbrfix"

# Application defaults

# Compute the semaphore name based on SCRIPT_NAME. 
SEMAPHORE_NAME="${SCRIPT_NAME}"

# Export configuration for convert_file function.
export INPUT_PATH="$(command pwd)"
export OUTPUT_PATH="$(command pwd)"

export INPUT_FORMAT="*"
export OUTPUT_FORMAT="mp3"

export ENCODING_MODE="VBR"
export ENCODING_BITRATE="192k"
export ENCODING_QUALITY="5"

export THREADS="100%"

export AVCONV_OPTIONS=""

export SYNC_DELETE='False'
export COPY_ALL='False'

export QUIET="False"
export VERBOSE="False"

export INPUT_EXTENSION="${INPUT_FORMAT}"
export OUTPUT_EXTENSION="${OUTPUT_FORMAT}"

# Parse options using getoptex from /usr/share/doc/bash-doc/examples/functions/getoptx.bash
while getoptex "help h input-path: in: i: output-path: out: o: input-format: if: output-format: of: e: bitrate. b. quality. q. threads: t: avconv-options: a: sync-delete delete d copy-all copy c quiet silent s verbose v" "${@}"; do
  # Options debuging.
  # echo "Option <$OPTOPT> ${OPTARG:+has an arg <$OPTARG>}"

  case "${OPTOPT}" in
    'input-path' | 'in' | 'i' )
      realpath_check "${OPTARG}"
      INPUT_PATH="${REALPATH}"
      ;;

    'output-path' | 'out' | 'o' )
      realpath_check "${OPTARG}"
      OUTPUT_PATH="${REALPATH}"
      ;;

    'input-format' | 'if' )
      if [ -n "${OPTARG}" ]; then
        INPUT_FORMAT="${OPTARG}"
      fi
      ;;

    'output-format' | 'of' | 'e' )
      if [ -n "${OPTARG}" ]; then
        OUTPUT_FORMAT="${OPTARG}"
      fi
      ;;

    'bitrate' | 'b' )
      ENCODING_MODE="CBR"

      if [ -n "${OPTARG}" ]; then
        ENCODING_BITRATE="${OPTARG}"
      fi
      ;;

    'quality' | 'q' )
      ENCODING_MODE="VBR"

      if [ -n "${OPTARG}" ]; then
        ENCODING_QUALITY="${OPTARG}"
      fi
      ;;

    'threads' | 't' )
      if [ -n "${OPTARG}" ]; then
        THREADS="${OPTARG}"
      fi
      ;;

    'avconv-options' | 'a' )
      if [ -n "${OPTARG}" ]; then
        AVCONV_OPTIONS="${OPTARG}"
      fi
      ;;

    'sync-delete' | 'delete' | 'd' )
      SYNC_DELETE='True'
      ;;

    'copy-all' | 'copy' | 'c' )
      COPY_ALL='True'
      ;;

    'quiet' | 'silent' | 's' )
      QUIET='True'
      ;;

    'verbose' | 'v' )
      VERBOSE='True'
      ;;

    'help' | 'h' | * )
      usage 0
      ;;
  esac
done

shift $[OPTIND-1]

if [ "${VERBOSE}" = 'True' ]; then
  QUIET='False'
fi

# Render formats with lowercase.
INPUT_FORMAT="$(command echo "${INPUT_FORMAT}" | command tr '[:upper:]' '[:lower:]')"
OUTPUT_FORMAT="$(command echo "${OUTPUT_FORMAT}" | command tr '[:upper:]' '[:lower:]')"


# TODO : implement a less basic extension detection based on format.

export INPUT_EXTENSION="${INPUT_FORMAT}"
case "${INPUT_FORMAT}" in
  'vorbis' | 'ogg' )
    INPUT_EXTENSION='ogg'
    ;;
esac

export OUTPUT_EXTENSION="${OUTPUT_FORMAT}"
case "${OUTPUT_FORMAT}" in
  'flac' | 'aiff' )
    # Defaults are good.
    ;;
  'mp3' )
    # Invert quality setting (9 is lowest, 0 highest).
    # This way mp3 and ogg/vorbis quality is set the same way.
    ENCODING_QUALITY=$((9 - ${ENCODING_QUALITY}))
    ;;
  'ogg' )
    OUTPUT_EXTENSION='ogg'
    OUTPUT_FORMAT='vorbis'
    ;;
  'vorbis' )
    OUTPUT_EXTENSION='ogg'
    ;;
  * )
    echo "Error: unsupported output format '${OUTPUT_FORMAT}'." >&2
    exit 1
esac

## Lock output path for this script.
lock "${OUTPUT_PATH}"

###############################
#
# Convert input files to output format.
#
################################

# Detect parallel command line based on OS.
case "$(command uname)" in
  'Darwin' )
    PARALLEL="${PARALLEL} --no-notice"
    ;;
  'Linux' | * )
    # Nothing to do.
    ;;
esac


command find "${INPUT_PATH}" -type 'f' -print0 \
  | command ${PARALLEL} --jobs ${THREADS} --null 'convert_file'


###############################
#
# Check for removed input files.
#
################################
if [ "${SYNC_DELETE}" = 'True' ]; then
  command find "${OUTPUT_PATH}" -type 'f' \
    | grep -v "${LOCK_DIR}" \
    | while read OUTPUT_FILE; do

    ## Build input file path based on output file path.
    OUTPUT_FILE_PATH="$(command dirname "${OUTPUT_FILE}")"
    INPUT_FILE_PATH="$(command echo "${OUTPUT_FILE_PATH}" | sed -e "s|^${OUTPUT_PATH}|${INPUT_PATH}|")"
    SHORT_PATH="$(command echo "${OUTPUT_FILE_PATH}" | sed -e "s|^${OUTPUT_PATH}||")"

    OUTPUT_FILENAME="$(command basename "${OUTPUT_FILE}")"
    INPUT_FILENAME_BASE="$(command echo -n "${OUTPUT_FILENAME}" \
        | command sed -e "s/\.[^\.]*$//")"

    SHORT_INPUT_FILE="${INPUT_FILENAME_BASE}.*"
    SHORT_OUTPUT_FILE="${OUTPUT_FILENAME}"

    # Test for file with same name (or without extension).
    if [ ! -e "${INPUT_FILE_PATH}/${OUTPUT_FILENAME}" ]; then
      if [ -z "$(command find "${INPUT_FILE_PATH}" -maxdepth 1 -type 'f' -iname "${INPUT_FILENAME_BASE}.*")" ]; then
        # Input file not found. Removing output file.
        test "${QUIET}" != 'True' && echo -n "File '${SHORT_INPUT_FILE}' disappeared.
   -> Removing '${SHORT_OUTPUT_FILE}'... "
        command test -e "${OUTPUT_FILE}" && command rm "${OUTPUT_FILE}"

        if [ -e "${OUTPUT_FILE}" ]; then
          test "${QUIET}" != 'True' && echo "Failed."
        else
          test "${QUIET}" != 'True' && echo "Done."
        fi

      fi
    fi
  done
fi

unlock
exit 0
